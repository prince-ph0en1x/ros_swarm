/**
 * \file check_mapp.cpp
 * 
 * \author Aritra Sarkar
 * \date 12-09-2017 (begin)
 */

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <cmath>
#include <regex>
#include <string>
#include <vector>
#include "hungarian.h"		// http://www2.informatik.uni-freiburg.de/~stachnis/misc.html
#include <chrono>
#include <iomanip>

using namespace std;
using namespace std::chrono;

const int INF = 1000000;

class HopcroftKarp
{
	
public:
	
	int* Pair_U;
	int* Pair_V;
	int** Adj;
	int NUM_U, NUM_V, NIL;

private:

	int* Dist;
	std::vector<int> Q;

	// ############################################## @$ ##############################################
	
public:

	HopcroftKarp(int sz)
	{
		NUM_U = sz;
		NUM_V = sz;
		Pair_U = new int[NUM_U];
		Pair_V = new int[NUM_V];
		Adj = new int*[NUM_U];
		for (int i = 0; i < NUM_U; i++)
			Adj[i] = new int[NUM_V];
		Dist = new int[NUM_U+1];
		NIL = NUM_U;
	}

	int maxmatch()
	{
		int u, v;
		for (u = 0; u < NUM_U; u++)
			Pair_U[u] = NIL;
		for (v = 0; v < NUM_V; v++)
			Pair_V[v] = NIL;
		int matching = 0;
		while (BFS()) {
			for (u = 0; u < NUM_U; u++) {
				if (Pair_U[u] == NIL && DFS(u))
					matching++;
			}
		}
		return matching;
	}

	// ############################################## @$ ##############################################

private:
	
	bool BFS()
	{
		int u, v;
		for (u = 0; u < NUM_U; u++) {
			if (Pair_U[u] == NIL) {
				Dist[u] = 0;
				Q.push_back(u);
			}
			else {
				Dist[u] = INF;
			}
		}
		Dist[NIL] = INF;
		while (Q.size() > 0) {
			u = Q.front();	
			Q.erase(Q.begin());
			if (Dist[u] < Dist[NIL]) {
				for (v = 0; v < NUM_V; v++) {
					if (Adj[u][v] == 0)
						continue;
					if (Dist[Pair_V[v]] == INF) {
						Dist[Pair_V[v]] = Dist[u] + 1;
						Q.push_back(Pair_V[v]);
					}
				}
			}
		}
		return (Dist[NIL] != INF);
	}
	
	// ############################################## @$ ##############################################
	
	bool DFS(int u)
	{
		int v;
		if (u != NIL) {
			for (v = 0; v < NUM_V; v++) {
				if (Adj[u][v] == 0)
					continue;
				if (Dist[Pair_V[v]] == Dist[u] + 1) {
					if (DFS(Pair_V[v])) {
						Pair_V[v] = u;
						Pair_U[u] = v;
						return true;
					}
				}
			}
			Dist[u] = INF;
			return false;	
		}
		return true;	
	}
	
};

class Hungarian
{
	
public:
	
	int** M;
	int size;
	
	Hungarian(int sz)
	{
		M = new int*[sz];
		for (int i = 0; i < sz; i++)
			M[i] = new int[sz];
		size = sz;
	}

	void runAlgo()
	{
		high_resolution_clock::time_point t1, t2;
		int a, o, cost_hgr = 0;
		hungarian_problem_t p;
		hungarian_init(&p,M,size,size,HUNGARIAN_MODE_MINIMIZE_COST);
		t1 = high_resolution_clock::now();	// start HGR time
		hungarian_solve(&p);
		t2 = high_resolution_clock::now();	// stop HGR time
		auto duration = duration_cast<microseconds>( t2 - t1 ).count();
		cout << "\nHGR Execution Duration --> " << duration << "ms\n";	
		string soln_ilp = "";
		for (a = 0; a < size; a++)
			for (o = 0; o < size; o++)
				soln_ilp += to_string(p.assignment[a][o]);
		cout << "HGR Solution Sequence (makespan + cost): " << soln_ilp << endl;
		for (a = 0; a < size; a++) {
			for (o = 0; o < size; o++) {
				if (p.assignment[a][o] == 1) {
					cout << M[a][o] << "\t";
					cost_hgr += M[a][o];
				}
				else {
					cout << ".\t";
				}
			}
			cout << "\n";
		}
		hungarian_free(&p);
		cout << "Total Cost = " << cost_hgr << std::endl;
	}


private:
	
	bool BFS()
	{}
	
};


	int main(int argc, char** argv)
	{
		srand(time(0));
		high_resolution_clock::time_point t1, t2;
		system("clear");
		system("clear");
		
		int u, v, a, o;
		if (argc < 2)
			u = 3;
		else
			u = atoi(argv[1]);

		int e[u][u];
		if (argc < 2) {
			e[0][0] = 70;		e[0][1] = 80;		e[0][2] = 50;
			e[1][0] = 3;		e[1][1] = 3;		e[1][2] = 69;
			e[2][0] = 10;		e[2][1] = 15;		e[2][2] = 62;			
		}
		else {
			for (a = 0; a < u; a++)
				for (o = 0; o < u; o++)
					e[a][o] = (int)(rand()/(double)RAND_MAX*9999);
		}
		
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++)
				cout << e[a][o] << "\t";
			cout << "\n";
		}

		string line, soln_ilp;
		int mksp_ilp = 0, cost_ilp = 0;
		regex re1("(^x[0-9]*)([[:space:]]*)([0-1]{1})");
		regex re2("(^mksp)([[:space:]]*)([0-9]+)");
		regex re3("(^cost)([[:space:]]*)([0-9]+)");
		smatch sm;

		ofstream ilp1;
		ilp1.open ("ilp1.lp");
		ilp1 << "\n/* PLEASE DO NOT EDIT THIS FILE */" << endl;
		ilp1 << "/* Auto-generated by check_mapp.cpp for lp_solve */\n" << endl;
		ilp1 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp1 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~ Hopcroft Karp Algorithm ILP formulation ~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp1 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n" << endl;
		ilp1 << "min: mksp;\n" << endl;
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				ilp1 << e[a][o] << " x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (o == u-1)				ilp1 << " < mksp;\n\n";
				else						ilp1 << " + ";
			}
		}
		for (o = 0; o < u; o++) {
			for (a = 0; a < u; a++) {
				ilp1 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (a == u-1)				ilp1 << " = 1;\n\n";
				else						ilp1 << " + ";
			}
		}
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				ilp1 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (o == u-1)				ilp1 << " = 1;\n\n";
				else						ilp1 << " + ";
			}
		}
		for (a = 0; a < u; a++) {
			ilp1 << "bin ";
			for (o = 0; o < u; o++) {
				ilp1 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (o == u-1)				ilp1 << ";\n\n";
				else						ilp1 << ", ";
			}
		}
		ilp1 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp1.close();
		
		t1 = high_resolution_clock::now();	// start ILP time
		system("lp_solve ilp1.lp > ilp1_soln.txt");
		t2 = high_resolution_clock::now();	// stop ILP time
		auto duration = duration_cast<microseconds>( t2 - t1 ).count();
		cout << "\nILP Execution Duration --> " << duration << "ms\n";
		ifstream ilp1_soln;
		ilp1_soln.open ("ilp1_soln.txt");
		soln_ilp = "";
		while (getline(ilp1_soln,line))
		{
			regex_search(line, sm, re2);
			if (sm.length() > 2)			mksp_ilp = stoi(sm[3]);
			regex_search(line, sm, re1);
			if (sm.length() > 2)			soln_ilp += sm[3];
		}
		ilp1_soln.close();
		cout << "ILP Solution Sequence (makespan) : " << soln_ilp << endl;
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				if (soln_ilp[a*u+o] == '1')	cout << e[a][o] << "\t";
				else						cout << ".\t";
			}
			cout << endl;
		}
		std::cout << "Makespan   = " << mksp_ilp << std::endl;
		for (a = 0; a < u; a++)
			for (o = 0; o < u; o++)
				if (soln_ilp[a*u+o] == '1')
					cost_ilp += e[a][o];
		cout << "Total Cost = " << cost_ilp << endl;

		HopcroftKarp hck(u);
		int max = 0, min = INF, mksp_hck, cost_hck = 0;
		bool found;
		string soln_hck = "";
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				if (e[a][o] < min)
					min = e[a][o];
				if (e[a][o] > max)
					max = e[a][o];
			}
		}
		
		t1 = high_resolution_clock::now();	// start HCK time
		for (mksp_hck = min; mksp_hck <= max; mksp_hck++) {
			for (a = 0; a < u; a++) {
				for (o = 0; o < u; o++) {
					if (e[a][o] <= mksp_hck)
						hck.Adj[a][o] = 1;
					else
						hck.Adj[a][o] = 0;
				}
			}
			found = false;
			for (a = 0; a < u; a++) {
				for (o = 0; o < u; o++) {
					if (e[a][o] == mksp_hck) {
						found = true;
						a = u;
						break;					
					}
				}
			}
			if (found == false)
				continue;
			if (hck.maxmatch() == u) {
				t2 = high_resolution_clock::now();	// stop HCK time
				duration = duration_cast<microseconds>( t2 - t1 ).count();
				cout << "\nHCK Execution Duration --> " << duration << "ms\n";
				for (a = 0; a < u; a++) {
					for (o = 0; o < u; o++) {
						if (o == hck.Pair_U[a])
							soln_hck += '1';
						else
							soln_hck += '0';
					}
				}
				std::cout << "HCK Solution Sequence (makespan) : " << soln_hck << endl;
				for (a = 0; a < u; a++) {
					for (o = 0; o < u; o++) {
						if (soln_hck[a*u+o] == '1') {
							cost_hck += e[a][o];
							cout << e[a][o] << "\t";
						}
						else
							cout << ".\t";
					}
					cout << endl;
				}
				
				std::cout << "Makespan   = " << mksp_hck << std::endl;
				std::cout << "Total Cost = " << cost_hck << std::endl;
				break;
			}
		}

		if (mksp_hck != mksp_ilp) {
			cout << "MAKESPAN DOES NOT MATCH, NOT PROCEEDING FOR FURTHER OPTIMIZATION" << endl;
			return 0;
		}

		for (a = 0; a < u; a++)
			for (o = 0; o < u; o++)
				if (e[a][o] > mksp_hck)
					e[a][o] = INF;
		
		ofstream ilp2;
		ilp2.open ("ilp2.lp");
		ilp2 << "\n/* PLEASE DO NOT EDIT THIS FILE */" << endl;
		ilp2 << "/* Auto-generated by check_mapp.cpp for lp_solve */\n" << endl;
		ilp2 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp2 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~ Hungarian Algorithm ILP formulation ~~~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp2 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n" << endl;
		ilp2 << "min: cost;\n" << endl;
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				ilp2 << e[a][o] << " x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (a == u-1 && o == u-1)	ilp2 << " = cost;\n\n";
				else						ilp2 <<	" + ";
			}
		}
		for (o = 0; o < u; o++) {
			for (a = 0; a < u; a++) {
				ilp2 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (a == u-1)				ilp2 << " = 1;\n\n";
				else						ilp2 << " + ";
			}
		}
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				ilp2 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (o == u-1)				ilp2 << " = 1;\n\n";
				else						ilp2 << " + ";
			}
		}
		for (a = 0; a < u; a++) {
			ilp2 << "bin ";
			for (o = 0; o < u; o++) {
				ilp2 << "x" << setfill('0') << setw(2) << a << setfill('0') << setw(3) << o;
				if (o == u-1)				ilp2 << ";\n\n";
				else						ilp2 << ", ";
			}
		}
		ilp2 << "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */" << endl;
		ilp2.close();
		t1 = high_resolution_clock::now();	// start ILP time
		system("lp_solve ilp2.lp > ilp2_soln.txt");
		t2 = high_resolution_clock::now();	// stop ILP time
		duration = duration_cast<microseconds>( t2 - t1 ).count();
		cout << "\nILP Execution Duration --> " << duration << "ms\n";
		ifstream ilp2_soln;
		ilp2_soln.open ("ilp2_soln.txt");
		soln_ilp = "";	
		while (getline(ilp2_soln,line))
		{
			regex_search(line, sm, re3);
			if (sm.length() > 2)			cost_ilp = stoi(sm[3]);
			regex_search(line, sm, re1);
			if (sm.length() > 2)			soln_ilp += sm[3];
		}
		ilp2_soln.close();
		cout << "ILP Solution Sequence (makespan + cost): " << soln_ilp << endl;
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				if (soln_ilp[a*u+o] == '1')	cout << e[a][o] << "\t";
				else						cout << ".\t";
			}
			cout << endl;
		}
		std::cout << "Total Cost = " << cost_ilp << std::endl;
		
		Hungarian hgr(u);
		for (a = 0; a < u; a++) {
			for (o = 0; o < u; o++) {
				hgr.M[a][o] = e[a][o];
			}
		}
		hgr.runAlgo();

		return 0;
	}
